---
title: "《游戏编程模式》"
date: 2021-12-07T11:44:19+08:00
draft: false
isCJKLanguage: true
---

阅读链接: https://gpp.tkchu.me/

> 没有正确的答案，只有不同的错误



## 重访设计模式

> 我认为有些模式被过度使用了（[单例模式](https://gpp.tkchu.me/singleton.html)）， 而另一些被冷落了（[命令模式](https://gpp.tkchu.me/command.html)）。 有些模式在这里是因为我想探索其在游戏上的特殊应用（[享元模式](https://gpp.tkchu.me/flyweight.html)和[观察者模式](https://gpp.tkchu.me/observer.html)）。 最后，我认为看看有些模式在更广的编程领域是如何运用的是很有趣的（[原型模式](https://gpp.tkchu.me/prototype.html)和[状态模式](https://gpp.tkchu.me/state.html)）。



### 命令模式

Command，将调用与被调用者解耦

- 修改输入按钮的映射

- Player与AI的输入方式虽然不同，但底层运作方式一般情况是一样的

  > Command执行时可以传入角色，这样Command就可以让玩家操作任意的角色，包括玩家和AI
  >
  > ```c++
  > Command* command = inputHandler.handleInput();
  > if (command)
  > {
  >   command->execute(actor);
  > }
  > ```

- Command类内部可以自己实现execute与undo两个方法，提供命令的回滚实现

- Command抽象，可以使得Command的来源可以是网络

> 在函数式编程中，Command其实是一个有状态的函数：闭包函数
>
> 在OOP中，Command则被封装成一个class用于保存状态
>
> ```javascript
> function makeMoveUnitCommand(unit, x, y) {
>   var xBefore, yBefore;
>   return {
>     execute: function() {
>       xBefore = unit.x();
>       yBefore = unit.y();
>       unit.moveTo(x, y);
>     },
>     undo: function() {
>       unit.moveTo(xBefore, yBefore);
>     }
>   };
> }
> ```
>
> 

### 享元模式

重复的对象只用一个对象即可，游戏开发场景常见用于，树的建模数据只有一份，然后会有多分树的高度、样式、颜色的类，这样就可以用最小的内存渲染出一个森林

### 观察者模式

- C#语言把观察者模式内置到语言特性上了（`event` 和`delegate`关键字）
- 一般游戏发中的观察者模式是同步执行的，这意味着所有观察者的通知方法返回后，被观察者才会继续自己的工作。观察者会阻塞被观察者。要小心在观察者中混合线程和锁。
- 可以用事件队列来做异步通知。
- 观察同一被观察者的两个观察者互相之间不该有任何顺序相关。 如果顺序*确实*有影响，这意味着这两个观察者有一些微妙的耦合。
- 如果两个完全不相干的领域（比如物理系统和成就系统）需要互相交流，那么就适合观察者模式，如果对一个需求要同时理解两个模块，那么这两个模块之间就不适用观察者模式。

引用书中一段话，我觉得很关键

> ## [今日观察者](https://gpp.tkchu.me/observer.html#今日观察者)
>
> *设计模式*源于1994。 那时候，面向对象语言*正是*热门的编程范式。 每个程序员都想要“30天学会面向对象编程”， 中层管理员根据程序员创建类的数量为他们支付工资。 工程师通过继承层次的深度评价代码质量。
>
> 同一年，Ace of Base的畅销单曲发行了*三首*而不是一首，这也许能让你了解一些我们那时的品味和洞察力。
>
> 观察者模式在那个时代中很流行，所以构建它需要很多类就不奇怪了。 但是现代的主流程序员更加适应函数式语言。 实现一整套接口只是为了接受一个通知不再符合今日的美学了。
>
> 
>
> 它看上去是又沉重又死板。它*确实*又沉重又死板。 举个例子，在观察者类中，你不能为不同的被观察者调用不同的通知方法。
>
> 这就是为什么被观察者经常将自身传给观察者。 观察者只有单一的`onNotify()`方法， 如果它观察多个被观察者，它需要知道哪个被观察者在调用它的方法。
>
> 现代的解决办法是让“观察者”只是对方法或者函数的引用。 在函数作为第一公民的语言中，特别是那些有闭包的， 这种实现观察者的方式更为普遍。
>
> 
>
> 今日，几乎*每种*语言都有闭包。C++克服了在没有垃圾回收的语言中构建闭包的挑战， 甚至Java都在JDK8中引入了闭包。
>
> 举个例子，C#有“事件”嵌在语言中。 通过这样，观察者是一个“委托”， （“委托”是方法的引用在C#中的术语）。 在JavaScript事件系统中，观察者*可以*是支持了特定`EventListener`协议的类， 但是它们也可以是函数。 后者是人们常用的方式。
>
> 如果设计今日的观察者模式，我会让它基于函数而不是基于类。 哪怕是在C++中，我倾向于让你注册一个成员函数指针作为观察者，而不是`Observer`接口的实例。
>
> [这里](http://molecularmusings.wordpress.com/2011/09/19/generic-type-safe-delegates-and-events-in-c/)的一篇有趣博文以某种方式在C++上实现了这一点。
>
> ## [明日观察者](https://gpp.tkchu.me/observer.html#明日观察者)
>
> 事件系统和其他类似观察者的模式如今遍地都是。 它们都是成熟的方案。 但是如果你用它们写一个稍微大一些的应用，你会发现一件事情。 在观察者中很多代码最后都长得一样。通常是这样：
>
> ```
> 1. 获知有状态改变了。
> 2. 下命令改变一些UI来反映新的状态。
> ```
>
> 就是这样，“哦，英雄的健康现在是7了？让我们把血条的宽度设为70像素。 过上一段时间，这会变得很沉闷。 计算机科学学术界和软件工程师已经用了*很长*时间尝试结束这种状况了。 这些方式被赋予了不同的名字：“数据流编程”，“函数反射编程”等等。
>
> 即使有所突破，一般也局限在特定的领域中，比如音频处理或芯片设计，我们还没有找到万能钥匙。 与此同时，一个更脚踏实地的方式开始获得成效。那就是现在的很多应用框架使用的“数据绑定”。
>
> 不像激进的方式，数据绑定不再指望完全终结命令式代码， 也不尝试基于巨大的声明式数据图表架构整个应用。 它做的只是自动改变UI元素或计算某些数值来反映一些值的变化。
>
> 就像其他声明式系统，数据绑定也许太慢，嵌入游戏引擎的核心也太复杂。 但是如果说它不会侵入游戏不那么性能攸关的部分，比如UI，那我会很惊讶。
>
> 与此同时，经典观察者模式仍然在那里等着我们。 是的，它不像其他的新热门技术一样在名字中填满了“函数”“反射”， 但是它超简单而且能正常工作。对我而言，这通常是解决方案最重要的条件。

### 原型模式

### 单例模式

> 保证一个类只有一个实例，**并且**提供了访问该实例的全局访问点。

#### 为什么我们使用它

 - ##### 惰性加载：

   如果没有人用，就不必创建实例；运行时初始化，可以获取运行时的一些环境变量

- ##### 可继承单例：

#### 为什么我们后悔使用它

- ##### 它是一个全局变量（全局变量万恶之源）

  - 理解代码更加困难：读取单例里的一个变量时，你要遍历整个代码库去发现这个变量究竟在什么时候读写的。
  - 促进了耦合的发生：因为可以全局调用，那么在一些不该调用的地方，其实是可以调用的，特别是团队来了新人，很容易出现这种耦合的调用。
  - 对并行不友好：全局变量意味着每个线程都能看到并且能访问的内存，却不知道其他线程是否在使用。这容易造成死锁、Race Condition以及其他难以解决的线程同步问题。

- ##### 它能在你只有一个问题的时候，解决两个

    回顾单例模式的描述：

    > 保证一个类只有一个实例，**并且**提供了访问该实例的全局访问点。

    这个【**并且**】就很奇怪，保证一个类只有一个实例是有用的，提供访问某个实例的全局访问点也是有用的，但这两个并不应该同时声明。

    - 保证单例可以使用assert() 强行保证一个类只会new 一次
    - 全局访问可以把类声明为纯static + static方法

- ##### 惰性加载可能在性能关键点被调用

#### 那咋办?

- 没有必要实现不必要的所谓的Manager类
- 将类限制为单一实例，可以用assert或者只是一个简单的bool值，在构造方法里判断
- 方便的访问方法
  - 通过构造函数传进来
  - 从基类获得
  - 从已经是全局的东西中获取：比如把Log、FileSystem等都放到一个叫Game或者World的静态类中，这样只有一个是全局可见的。少部分获取不到Game::Log的再考虑直接调用Log
  - 从服务定位器中获得：这个在另一个篇章中单独介绍

### 状态模式

> 状态模式，与有限状态机、分层状态机、下推自动机不是一回事儿

Fsm是状态模式的具体实现，但其实有时候声明几个Enum来做Enum之间的跳转声明，也是可以实现状态模式的

## 序列模式

### 游戏循环

一个游戏循环，需要无阻塞的**处理玩家输入**、**更新游戏状态**、**渲染游戏**，它追踪时间的消耗并**控制游戏的速度**。

我们这里谈到的循环是游戏代码中最重要的部分。 有人说程序会花费90%的时间在10%的代码上。 游戏循环代码肯定在这10%中。 你必须小心谨慎，时时注意效率。

游戏循环主要分四种：

#### 固定时间步长，没有同步

```
while (true)
{
  processInput();
  update();
  render();
}
```

指定每一次循环的deltaTime，但是并不与真实时间同步，意味着机器性能越好，循环执行得越快，机器性能越差，循环执行得越差，但它在逻辑上是指定每一次循环的deltaTime的。
- 简单，几乎是它唯一的优点
- 游戏速度直接受到硬件和游戏复杂度影响。

#### 固定时间步长，有同步

```
while (true)
{
  double start = getCurrentTime();
  processInput();
  update();
  render();

  sleep(start + MS_PER_FRAME - getCurrentTime());
}
```

加一个与真实时间的同步

- 简单
- 电量友好。在移动游戏开发中，不必要消耗的电量，通过简单的休眠几个毫秒，就节省了电量
- 游戏不会运行得太快
- 游戏可能运行得太慢。如果一次循环花了太多时间更新或者渲染，那么就会变慢

#### 动态时间步长

```
double lastTime = getCurrentTime();
while (true)
{
  double current = getCurrentTime();
  double elapsed = current - lastTime;
  processInput();
  update(elapsed);
  render();
  lastTime = current;
}
```

其实就是动态的把`elapsed`传到每一个Update中，让代码中可以写这样的实现

```
var deltaMove = Speed * elapsed;
```

大多数（作者认识的）游戏开发者反对这个解决方案，不过记住为什么反对它是有价值的：

- 能适应并调整，避免运行得太快或者太慢。如果游戏不能追上真实的时间，这个方法可以用越来越长的时间步长更新，直到追上。
- 让游戏不确定而且不稳定。这是真正的问题。在物理和网络部分使用动态时间步长则会遇见更多的困难。

#### 固定时间步长，动态渲染

```
double previous = getCurrentTime();
double lag = 0.0;
while (true)
{
  double current = getCurrentTime();
  double elapsed = current - previous;
  previous = current;
  lag += elapsed;

  processInput();

  while (lag >= MS_PER_UPDATE)
  {
    update();
    lag -= MS_PER_UPDATE;
  }

  render();
  // render(lag / MS_PER_UPDATE); // 这种做法可以让渲染更流畅
}
```

- 能适应并调整，避免运行得太快或太慢。只要能实时更新，游戏状态就不会落后于真实事件。如果玩家用高端机器，它会回以更平滑得游戏体验。
- 更复杂。主要负面问题是需要在实现中写更多东西。你需要将更新的时间步长调整得尽可能小来适应高端机，同时不至于在低端机上太慢。
