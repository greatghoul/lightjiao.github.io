---
title: "《游戏编程模式》"
date: 2021-12-07T11:44:19+08:00
draft: false
isCJKLanguage: true
---

阅读链接: https://gpp.tkchu.me/

> 没有正确的答案，只有不同的错误



## 重访设计模式

> 我认为有些模式被过度使用了（[单例模式](https://gpp.tkchu.me/singleton.html)）， 而另一些被冷落了（[命令模式](https://gpp.tkchu.me/command.html)）。 有些模式在这里是因为我想探索其在游戏上的特殊应用（[享元模式](https://gpp.tkchu.me/flyweight.html)和[观察者模式](https://gpp.tkchu.me/observer.html)）。 最后，我认为看看有些模式在更广的编程领域是如何运用的是很有趣的（[原型模式](https://gpp.tkchu.me/prototype.html)和[状态模式](https://gpp.tkchu.me/state.html)）。



### 命令模式

Command，将调用与被调用者解耦

- 修改输入按钮的映射

- Player与AI的输入方式虽然不同，但底层运作方式一般情况是一样的

  > Command执行时可以传入角色，这样Command就可以让玩家操作任意的角色，包括玩家和AI
  >
  > ```c++
  > Command* command = inputHandler.handleInput();
  > if (command)
  > {
  >   command->execute(actor);
  > }
  > ```

- Command类内部可以自己实现execute与undo两个方法，提供命令的回滚实现

- Command抽象，可以使得Command的来源可以是网络

> 在函数式编程中，Command其实是一个有状态的函数：闭包函数
>
> 在OOP中，Command则被封装成一个class用于保存状态
>
> ```javascript
> function makeMoveUnitCommand(unit, x, y) {
>   var xBefore, yBefore;
>   return {
>     execute: function() {
>       xBefore = unit.x();
>       yBefore = unit.y();
>       unit.moveTo(x, y);
>     },
>     undo: function() {
>       unit.moveTo(xBefore, yBefore);
>     }
>   };
> }
> ```
>
> 

### 享元模式

重复的对象只用一个对象即可，游戏开发场景常见用于，树的建模数据只有一份，然后会有多分树的高度、样式、颜色的类，这样就可以用最小的内存渲染出一个森林

### 观察者模式

- C#语言把观察者模式内置到语言特性上了（`event` 和`delegate`关键字）
- 一般游戏发中的观察者模式是同步执行的，这意味着所有观察者的通知方法返回后，被观察者才会继续自己的工作。观察者会阻塞被观察者。要小心在观察者中混合线程和锁。
- 可以用事件队列来做异步通知。
- 观察同一被观察者的两个观察者互相之间不该有任何顺序相关。 如果顺序*确实*有影响，这意味着这两个观察者有一些微妙的耦合。
- 如果两个完全不相干的领域（比如物理系统和成就系统）需要互相交流，那么就适合观察者模式，如果对一个需求要同时理解两个模块，那么这两个模块之间就不适用观察者模式。

引用书中一段话，我觉得很关键

> ## [今日观察者](https://gpp.tkchu.me/observer.html#今日观察者)
>
> *设计模式*源于1994。 那时候，面向对象语言*正是*热门的编程范式。 每个程序员都想要“30天学会面向对象编程”， 中层管理员根据程序员创建类的数量为他们支付工资。 工程师通过继承层次的深度评价代码质量。
>
> 同一年，Ace of Base的畅销单曲发行了*三首*而不是一首，这也许能让你了解一些我们那时的品味和洞察力。
>
> 观察者模式在那个时代中很流行，所以构建它需要很多类就不奇怪了。 但是现代的主流程序员更加适应函数式语言。 实现一整套接口只是为了接受一个通知不再符合今日的美学了。
>
> 
>
> 它看上去是又沉重又死板。它*确实*又沉重又死板。 举个例子，在观察者类中，你不能为不同的被观察者调用不同的通知方法。
>
> 这就是为什么被观察者经常将自身传给观察者。 观察者只有单一的`onNotify()`方法， 如果它观察多个被观察者，它需要知道哪个被观察者在调用它的方法。
>
> 现代的解决办法是让“观察者”只是对方法或者函数的引用。 在函数作为第一公民的语言中，特别是那些有闭包的， 这种实现观察者的方式更为普遍。
>
> 
>
> 今日，几乎*每种*语言都有闭包。C++克服了在没有垃圾回收的语言中构建闭包的挑战， 甚至Java都在JDK8中引入了闭包。
>
> 举个例子，C#有“事件”嵌在语言中。 通过这样，观察者是一个“委托”， （“委托”是方法的引用在C#中的术语）。 在JavaScript事件系统中，观察者*可以*是支持了特定`EventListener`协议的类， 但是它们也可以是函数。 后者是人们常用的方式。
>
> 如果设计今日的观察者模式，我会让它基于函数而不是基于类。 哪怕是在C++中，我倾向于让你注册一个成员函数指针作为观察者，而不是`Observer`接口的实例。
>
> [这里](http://molecularmusings.wordpress.com/2011/09/19/generic-type-safe-delegates-and-events-in-c/)的一篇有趣博文以某种方式在C++上实现了这一点。
>
> ## [明日观察者](https://gpp.tkchu.me/observer.html#明日观察者)
>
> 事件系统和其他类似观察者的模式如今遍地都是。 它们都是成熟的方案。 但是如果你用它们写一个稍微大一些的应用，你会发现一件事情。 在观察者中很多代码最后都长得一样。通常是这样：
>
> ```
> 1. 获知有状态改变了。
> 2. 下命令改变一些UI来反映新的状态。
> ```
>
> 就是这样，“哦，英雄的健康现在是7了？让我们把血条的宽度设为70像素。 过上一段时间，这会变得很沉闷。 计算机科学学术界和软件工程师已经用了*很长*时间尝试结束这种状况了。 这些方式被赋予了不同的名字：“数据流编程”，“函数反射编程”等等。
>
> 即使有所突破，一般也局限在特定的领域中，比如音频处理或芯片设计，我们还没有找到万能钥匙。 与此同时，一个更脚踏实地的方式开始获得成效。那就是现在的很多应用框架使用的“数据绑定”。
>
> 不像激进的方式，数据绑定不再指望完全终结命令式代码， 也不尝试基于巨大的声明式数据图表架构整个应用。 它做的只是自动改变UI元素或计算某些数值来反映一些值的变化。
>
> 就像其他声明式系统，数据绑定也许太慢，嵌入游戏引擎的核心也太复杂。 但是如果说它不会侵入游戏不那么性能攸关的部分，比如UI，那我会很惊讶。
>
> 与此同时，经典观察者模式仍然在那里等着我们。 是的，它不像其他的新热门技术一样在名字中填满了“函数”“反射”， 但是它超简单而且能正常工作。对我而言，这通常是解决方案最重要的条件。

### 原型模式

