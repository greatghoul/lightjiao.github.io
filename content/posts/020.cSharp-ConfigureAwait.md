---
title: 【译】 ConfigureAwait FAQ
date: 2020-11-23T20:01:37+08:00
draft: true
isCJKLanguage: true
tags:
 - CSharp
---


> 原文链接 https://devblogs.microsoft.com/dotnet/configureawait-faq/


# ConfigureAwait FAQ

七年前.NET在语言和标准库中添加了`async/await`关键字。那时候它引起了一阵热潮，不仅仅是.NET生态（ecosystem），其他无数的（myriad）语言和框架也对它进行了模仿。在语言层面的异步构造、异步API的支持、以及`async/await`等待的基础设施进行了根本性改变后，.Net有了非常多的改进。（特别是性能和支持诊断（译注：可能是指debug的易用性）的改进）。

但是，`async/await`同时也引出了一个问题叫`ConfigureAwait`。在这篇博文中，我希望回答一些这方面的问题。希望这篇博文能成为一个通篇可读的FAQ（frequently Asked Question）列表，可以用作将来的参考。

为了真正明白`ConfigureAwait`，我们需要从比较早的内容开始...

> 译注：
>
> `ConfigureAwait`的用法说明，会使得await的函数调用是在当前线程，还是一个新的线程
>
> ```c#
> using System;
> using System.Threading;
> using System.Threading.Tasks;
> 
> namespace cSharpSolution
> {
>     internal class Program
>     {
>         private static void Main(string[] args)
>         {
>             Task.WaitAll(ConfigureAwait());
>         }
> 
>         private static async Task ConfigureAwait()
>         {
>             Console.WriteLine($"main Thread id: {Thread.CurrentThread.ManagedThreadId}");
>             await PrintAsync("ConfigureAwait(true)").ConfigureAwait(true);
>             await PrintAsync("ConfigureAwait(false)").ConfigureAwait(false);
>         }
> 
>         private static async Task PrintAsync(string str)
>         {
>             Console.WriteLine($"{str} :await thread {Thread.CurrentThread.ManagedThreadId}");
> 
>             // 有一个空的await，才会让编译器认为这个函数真的是一个异步函数，会使得ConfigureAwait的设置生效
>             // 如果没有空的await，那么整个异步调用会被编译器优化为同步调用函数，ConfigureAwait的设置当然不论怎么设置都不会生效
>             await Task.Run(() => { });
>         }
>     }
> }
> ```
>
> 输出
>
> ```
> main Thread id: 1
> ConfigureAwait(true) :await thread 1
> ConfigureAwait(false) :await thread 4
> ```

### 什么是SynchronizationContext?

[`System.Threading.SynchronizationContext`文档](https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext)说 “提供用于在各种同步模型中传播同步上下文的基本功能”，这显然不是一个容易理解的描述。

在99.9%的使用场景，`SynchronizationContext`仅仅是提供了一个 virtual `Post` 方法，这个方法接受一个delegate以异步的方式执行（还有其他的virtual方法，但它们不常用而且与这次讨论无关）。基类中的`Post`方法实际上（literally）是调用`ThreadPool.QueueUserWorkItem`去异步的执行delegate。然而派生类可以override `Post`方法使得这个delegate在最合适的地方最合适的时间执行。

比如说，Windows Forms有一个[`SynchronizationContext`派生类](https://github.com/dotnet/winforms/blob/94ce4a2e52bf5d0d07d3d067297d60c8a17dc6b4/src/System.Windows.Forms/src/System/Windows/Forms/WindowsFormsSynchronizationContext.cs)，它override了`Post`方法使得等同于`Control.BeginInvoke`，这意味着对其`Post`方法的任意调用的委托，都将导致稍后在与Control相关联的线程调用（也就是UI线程）。Windows Forms依赖win32消息处理，UI线程有一个简单的一直等待新消息去处理的“消息死循环”。这些消息可以是鼠标的移动和点击、可以是键盘输入、可以是系统时间、可以是可调用的委托等等。所以给Windows Forms应用的UI线程一个`SynchronizationContext`实例，当需要在UI线程上执行一个delegate时，只需要传参给`Post`方法就可以了

> 译注：
>
> 这里并不是说在UI上异步的执行一个delegate，而是把一个delegate通过SynchronizationContext传递到UI线程去执行。
>
> 译者疑问：
>
> 没有Windows Forms相关的编程经验，什么情况下需要主动传递一个delegate给UI线程调用？让UI获取数据吗？

这样的例子在WPF（Windows Presentation Foundation）上也有。它有自己的[`SynchronizationContext`派生类](https://github.com/dotnet/wpf/blob/ac9d1b7a6b0ee7c44fd2875a1174b820b3940619/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Threading/DispatcherSynchronizationContext.cs)，重写了`Post`方法将delegate“封送到”UI线程上执行（通过`Dispatcher.BeginInvoke`），只是在这种情况下，由WPF Dispatcher而不是Windows Forms Control管理。

再就是WInRT（WIndows RunTime）。它有自己的 [`SynchronizationContext`派生类](https://github.com/dotnet/runtime/blob/60d1224ddd68d8ac0320f439bb60ac1f0e9cdb27/src/libraries/System.Runtime.WindowsRuntime/src/System/Threading/WindowsRuntimeSynchronizationContext.cs) 重写 `Post` 方法，通过`CoreDispatcher`将委托排队到在UI线程上。

---

这超出了“在UI线程上运行此委托”的范围。任何人都可以实现`SynchronizationContext`的`Post`方法做任何事。比如，我也许并不关心delegate运行在哪个线程上，但我希望`Post`到我的`SynchronizationContext`的任何委托都以一定程度的并发度（concurrency）执行。我可以自定义一个下面这样的`SynchronizationContext`做到这些：

```c#
internal sealed class MaxConcurrencySynchronizationContext : SynchronizationContext
{
    private readonly SemaphoreSlim _semaphore;

    public MaxConcurrencySynchronizationContext(int maxConcurrencyLevel) =>
        _semaphore = new SemaphoreSlim(maxConcurrencyLevel);

    public override void Post(SendOrPostCallback d, object state) =>
        _semaphore.WaitAsync().ContinueWith(delegate
        {
            try { d(state); } finally { _semaphore.Release(); }
        }, default, TaskContinuationOptions.None, TaskScheduler.Default);

    public override void Send(SendOrPostCallback d, object state)
    {
        _semaphore.Wait();
        try { d(state); } finally { _semaphore.Release(); }
    }
}
```

其实，单元测试框架xunit [提供的`SynchronizationContext`](https://github.com/xunit/xunit/blob/d81613bf752bb4b8774e9d4e77b2b62133b0d333/src/xunit.execution/Sdk/MaxConcurrencySyncContext.cs)与这个非常相像，它用于限制测试用例相关的代码的并发执行。

所有的这些好处与我们熟悉的抽象是一样的：它提供了一个API，可用于将delegate排队，创建者可以用他希望的方式实现，调用者不用了解该实现的细节。所以如果我正在编写一个库，并且想要离开并做一些工作，然后将delegate排队回到原始的“上下文”，我只需要获取它们的`SynchronizationContext`，当我做完我的工作的时候，在该上下文调用`Post`即可移交我需要调用的delegate。我不需要知道对windows窗口去获取`Control`掉哦那个`BeginInvoke`，或者对WPF来说获取`Dispatcher`并且调用`BeginInvoke`，或者对xunit来说我或许应该引入它的上下文并且排队；我只需要简单的获取`SynchronizationContext`并且在之后使用它即可。为此，`SynchronizationContext`提供了一个`Current`属性，以便实现上述目标，代码可能写成这样：

```csharp
public void DoWork(Action worker, Action completion)
{
    SynchronizationContext sc = SynchronizationContext.Current;
    ThreadPool.QueueUserWorkItem( _ => 
        {
        	try {worker();}
            finally {sc.Post( _ => completion(), null ); }
    	}
    );
}
```

想要从`Current`公开自定义上下文的框架使用`SynchronizationContext.SetSynchronizationContext`方法。



### 什么是TaskScheduler?

`SynchronizationContext`是对“scheduler”的通用抽象。独立的框架有时候有它自己对“scheduler”的抽象，`System.Threading.Tasks`也不例外（is no exception）。当`Task`s由delegate支持并且可以排队和执行的时候，它就与`System.Threading.Tasks.TaskScheduler`相关联。像`SynchronizationContext`提供一个virtual `Post`的方法用于排队delegeate的调用一样，`TaskScheduler`提供一个abstract `QueueTask`方法（通过`ExecuteTask`方法来实现稍后调用`Task`）。

`TaskScheduler.Default`默认返回的sheduler是线程池（thread pool），但可以通过派生`TaskScheduler`并且重写相关的方法实现任意时间任意地方调用`Task`。比如包括`System.Threading.Tasks.ConcurrentExclusiveSchedulerPair`在内的核心库都有这种实现。这个类的实例有两个`TaskScheduler`属性，一个`ExclusiveScheduler`，一个`ConcurrentScheduler`。在`ConcurrentScheduler`中调度的`Task`可能会被并发的调用，但受`ConcurrentExclusiveSchedulerPair`参数的限制（构造函数的时候提供），而且在`ExclusiveScheduler`中的`Task`运行的时候`ConcurrentScheduler`中的`Task`则不会执行，`ExclusiveScheduler`一次只允许一个`Task`运行，这个行为很像一个读写锁。

像`SynchronizationContext`那样，`TaskScheduler`也有一个`Current`属性，用于返回“当前的” `TaskScheduler`。而不像`SynchronizationContext`的，没有方法支持set当前的scheduler。相反，当前的scheduler（调度程序）是与当前运行的Task相关联的scheduler，并且scheduler作为启动Task的一部分提供给系统。举个例子，下面的程序将输出“ True”，因为与StartNew一起使用的lambda是在`ConcurrentExclusiveSchedulerPair`的`ExclusiveScheduler`上执行的，并且将看到`TaskScheduler.Current`设置为该调度程序：

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        var cesp = new ConcurrentExclusiveSchedulerPair();
        Task.Factory.StartNew(
            () => {
                Console.WriteLine(TaskScheduler.Current == cesp.ExclusiveScheduler);
            },
            default,
            TaskCreationOptions.None, cesp.ExclusiveScheduler
        ).Wait();
    }
}
```

有趣的是，`TaskScheduler`提供了一个静态的`FromCurrentSynchronizationContext`方法，该方法创建了一个新的`TaskScheduler`，该任务将任务排队，以便在其返回的`SynchronizationContext.Current`上运行，并使用其Post方法对任务进行排队。



### 那么，SynchronizationContext 与 TaskScheduler 与 await 有什么关系呢？

想象一下，在写一个带有`Button`的UI app。点击按钮后，我们希望从web上下载一些文本，并且将文本设置成为`Button`的`Content`。仅应从拥有`Button`的UI线程访问`Button`，因此，当我们成功下载新的日期和时间文本并将其存储回`Button`的内容时，我们需要从拥有`Button`的线程中进行操作。如果不这样做，则会出现类似以下的异常：

```
System.InvalidOperationException: 'The calling thread cannot access this object because a different thread owns it.'
```

如果我们手动写这些实现，则可以我们前面说的`SynchronizationContext`将Content的设置编组回原始上下文，例如通过TaskScheduler：

```c#
private static readonly HttpClient s_httpClient = new HttpClient();

private void downloadBtn_Click(object sender, RoutedEventArgs e)
{
    s_httpClient.GetStringAsync("http://example.com/currenttime").ContinueWith(downloadTask =>
    {
        downloadBtn.Content = downloadTask.Result;
    }, TaskScheduler.FromCurrentSynchronizationContext());
}
```

或者直接用`SynchronizationContext`:

```c#
private static readonly HttpClient s_httpClient = new HttpClient();

private void downloadBtn_Click(object sender, RoutedEventArgs e)
{
    SynchronizationContext sc = SynchronizationContext.Current;
    s_httpClient.GetStringAsync("http://example.com/currenttime").ContinueWith(downloadTask =>
    {
        sc.Post(delegate
        {
            downloadBtn.Content = downloadTask.Result;
        }, null);
    });
}
```

但是，这两种写法都明确使用了回调，我们希望使用`async/await` 自然的编写代码：

```c#
private static readonly HttpClient s_httpClient = new HttpClient();

private async void downloadBtn_Click(object sender, RoutedEventArgs e)
{
    string text = await s_httpClient.GetStringAsync("http://example.com/currenttime");
    downloadBtn.Content = text;
}
```

这“有效”，成功地在UI线程上设置了Content，因为与上述手动实现的版本一样，`awaiting` `Task`在默认情况下关注`SynchronizationContext.Current`以及`TaskScheduler.Current`。当您在C＃中`await`任何内容时，编译器将转换代码以（通过调用GetAwaiter）向“awaitable”（在这种情况下为`Task`）询问“awaiter”（在这种情况下为`TaskAwaiter <string>`）。该awaiter负责挂接回调（通常称为“Continuation”），该回调将在等待的对象完成时回调到状态机中，并使用在回调时捕获的任何上下文/调度程序来完成此操作。注册。虽然使用的代码不完全相同（还进行了其他优化和调整），但实际上是这样的：

```c#
object scheduler = SynchronizationContext.Current;
if (scheduler is null && TaskScheduler.Current != TaskScheduler.Default)
{
    scheduler = TaskScheduler.Current;
}
```

换句话说，它首先检查是否设置了SynchronizationContext，如果没有，则判断在运行中是否存在非默认的TaskScheduler。

如果找到了上面的其中一个，则在调用delegate时候使用获取到的`scheduler`（上下文）（也就是可以通过这种方式切换回去到主线程执行）；否则，它只是在执行完awaited task的上下文中执行回调。

### 所以，ConfigureAwait(false) 做了什么？

`ConfigureAwait`方法并不特殊：编译器或者运行时都不能用特殊的方式去识别它。它只是返回一个结构体（`ConfiguredTaskAwaitable`），包含了原始的task和一个指定的布尔值。请记住`await`可以与任何公开了正确模式的类型一起使用。通过返回不同的类型，意味着编译器访问`GetAwaiter`方法，是通过`ConfigureAwait`返回的类型访问，而不是直接的通过task访问。并且提供了一个钩子，用于通过此自定义`awaiter`来改变await的行为。

具体的说，等待`ConfigureAwait(continueOnCapturedContext: false)`的返回类型和直接等待`Task`直接的影响了我们前面探讨的如何获取上下文的逻辑。我们前面说的逻辑会编程大概这样：

```c#
object scheduler = null;
if (continueOnCapturedContext)
{
    scheduler = SynchronizationContext.Current;
    if (scheduler is null && TaskScheduler.Current != TaskScheduler.Default)
    {
        scheduler = TaskScheduler.Current;
    }
}
```

换句话说，通过指定`false`，即使指定了执行回调的上下文，但会假装没有……



### 我为什么想要用ConfigureAwait(false)?

`ConfigureAwait(continueOnCapturedContext: false)`用于强行避免回调会被在原始的上下文（original context or scheduler）中执行。会有这样的一些好处：

- 提升性能：

  比起直接执行回调函数，将回调函数排队是有开销的，因为它有额外的工作包含了进来（通常是额外的内存分配），而且这意味着一些特定的运行时性能优化不能使用（当我们确切的知道回调将如何调用时，我们可以进行更多优化，但是如果将它移交给抽象的排队实现，我们会有些收到限制）。最常见的，仅仅是检查当前`SynchronizationContext`和当前`TaskScheduler`的额外开销也都是肉眼可见的。

  如果`await`后面的代码实际上并没有一定要求在原始上下文中运行，使用`ConfigureAwait(false)`能减少这些开销：

  - 不需要做不必要的排队
  - 可以尽可能的做性能优化（由于不排队，那么执行时机是可控的）
  - 减少不必要的静态方法访问

- 避免死锁：

  想象一下一个库的方法使用`await`来获取网络下载的结果。你执行了这个方法，并且同步的阻塞等待它执行结束，比如通过对返回的`task`对象调用`.Wait()` `.Result` `.GetAwaiter().GetResult()` 。现在考虑一下，如果当前的`SynchronizationContext`限制了最大数量为1会发生什么（不论是通过设置`MaxConcurrencySynchronizationContext`，还是把它当作UI线程那样只有一个线程可用的上下文）。你在这个线程上执行了一个方法并且阻塞的等待它执行结束，这个操作启动网络下载并且等待它。由于默认情况下，awaiting 的 task 将捕获当前的`SynchronizationContext`，并且当网络下载完成时，它将会排队回到`SynchronizationContext`执行回调完成剩下的操作。但唯一能够处理回调队列的线程又被你的代码阻塞等待着操作执行结束。而这个操作要等到回调执行被队列处理掉才会结束。啪，这就死锁了！这种情况不只是会出现在上下文数量限制为1的情况，只要资源的数量是有限制的，就都会发生。想象一下用`MaxConcurrencySynchronizationContext`将上下文的数量限制为 4 的同样的场景。我们的操作不只是执行一次调用，而是排队4个回调给到原始上下文，每一个回调都要求阻塞的等待结束。我们现在依然阻塞了所有的资源去等待异步的方法完成。（译者注：4个的场景我没看懂）

  如果将这个库中的方法使用`ConfigureAwait(false)`，它就不会将回调函数进行排队回到原始上下文，会避免死锁的场景。



### 我为什么想用ConfigureAwait(true)?

不，你不想！除非你纯粹将其用作表明你有使用`ConfigureAwait(false)`的指示（例如使静态分析警告保持沉默）。`ConfigureAwait(true)`没有意义。使用`await task`和`await task.ConfigureAwait(true)`完全一样。如果你在生产环境看到`ConfigureAwait(true)`的代码，你可以直接删了它并且不会有不好的影响。

`ConfigureAwait`方法接受布尔值入参，是因为某些特殊情况下，你需要传递变量来控制配置。但99%的用例带有硬编码的`false`入参`ConfigureAwait(false)`



### 什么时候应该用ConfigureAwait(false)？















