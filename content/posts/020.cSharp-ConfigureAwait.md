---
title: 翻译总结 ConfigureAwait FAQ
date: 2020-11-23T20:01:37+08:00
draft: true
isCJKLanguage: true
tags:
 - CSharp
---

# ConfigureAwait FAQ

七年前.NET在语言和标准库中添加了`async/await`关键字。那时候它引起了一阵热潮，不仅仅是.NET生态（ecosystem），其他无数的（myriad）语言和框架也对它进行了模仿。它也对.NET有了大幅提高



### 什么是SynchronizationContext?

[`System.Threading.SynchronizationContext`文档](https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext)说 “提供用于在各种同步模型中传播同步上下文的基本功能”，这显然不是一个容易理解的描述。

在99.9%的使用场景，`SynchronizationContext`仅仅是提供了一个 virtual `Post` 方法，这个方法接受一个delegate以异步的方式执行（还有其他的virtual方法，但它们不常用而且与这次讨论无关）。基类中的`Post`方法实际上（literally）是调用`ThreadPool.QueueUserWorkItem`去异步的执行delegate。然而派生类可以override `Post`方法使得这个delegate在最合适的地方最合适的时间执行。

比如说，windows 窗口有一个[`SynchronizationContext`派生类](https://github.com/dotnet/winforms/blob/94ce4a2e52bf5d0d07d3d067297d60c8a17dc6b4/src/System.Windows.Forms/src/System/Windows/Forms/WindowsFormsSynchronizationContext.cs)，它override了`Post`方法使得等同于`Control.BeginInvoke`，这意味着对其`Post`方法的任意调用的委托，都将导致稍后在与Control相关联的线程调用（也就是UI线程）。windiws窗口依赖win32消息处理，UI线程有一个简单的一直等待新消息去处理的“消息死循环”。这些消息可以是鼠标的移动和点击、可以是键盘输入、可以是系统时间、可以是可调用的委托等等。所以windows窗口应用的UI线程只要有`SynchronizationContext`实例，想要在UI线程上执行一个delegate，只需要传参给`Post`方法就可以了。

这样的例子在WPF（Windows Presentation Foundation）上也有。它有自己的[`SynchronizationContext`派生类](https://github.com/dotnet/wpf/blob/ac9d1b7a6b0ee7c44fd2875a1174b820b3940619/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Threading/DispatcherSynchronizationContext.cs)，重写了`Post`方法类似的“封送”delegate到UI线程（通过`Dispatcher.BeginInvoke`），在这种情况下，由WPF Dispatcher而不是Windows Forms Control管理。

再就是WInRT（WIndows RunTime）。它有自己的 [`SynchronizationContext`派生类](https://github.com/dotnet/runtime/blob/60d1224ddd68d8ac0320f439bb60ac1f0e9cdb27/src/libraries/System.Runtime.WindowsRuntime/src/System/Threading/WindowsRuntimeSynchronizationContext.cs) 重写 `Post` 方法，通过`CoreDispatcher`将委托排队到在UI线程上。

这超出了“在UI线程上运行此委托”的范围。任何人都可以实现`SynchronizationContext`的`Post`方法做任何事。比如，我也许并不关心delegate运行在哪个线程上，但我希望`Post`到我的`SynchronizationContext`的任何委托都以一定程度的并发度（concurrency）执行。我可以自定义一个下面这样的`SynchronizationContext`做到这些：

```c#
internal sealed class MaxConcurrencySynchronizationContext : SynchronizationContext
{
    private readonly SemaphoreSlim _semaphore;

    public MaxConcurrencySynchronizationContext(int maxConcurrencyLevel) =>
        _semaphore = new SemaphoreSlim(maxConcurrencyLevel);

    public override void Post(SendOrPostCallback d, object state) =>
        _semaphore.WaitAsync().ContinueWith(delegate
        {
            try { d(state); } finally { _semaphore.Release(); }
        }, default, TaskContinuationOptions.None, TaskScheduler.Default);

    public override void Send(SendOrPostCallback d, object state)
    {
        _semaphore.Wait();
        try { d(state); } finally { _semaphore.Release(); }
    }
}
```

其实，单元测试框架xunit [提供的`SynchronizationContext`](https://github.com/xunit/xunit/blob/d81613bf752bb4b8774e9d4e77b2b62133b0d333/src/xunit.execution/Sdk/MaxConcurrencySyncContext.cs)与这个非常相像，它用于限制测试用例相关的代码的并发执行。

所有的这些好处与我们熟悉的抽象是一样的：它提供了一个API，可用于将delegate排队，创建者可以用他希望的方式实现，调用者不用了解该实现的细节。所以如果我正在编写一个库，并且想要离开并做一些工作，然后将delegate排队回到原始的“上下文”，我只需要获取它们的`SynchronizationContext`，当我做完我的工作的时候，在该上下文调用`Post`即可移交我需要调用的delegate。我不需要知道对windows窗口去获取`Control`掉哦那个`BeginInvoke`，或者对WPF来说获取`Dispatcher`并且调用`BeginInvoke`，或者对xunit来说我或许应该引入它的上下文并且排队；我只需要简单的获取`SynchronizationContext`并且在之后使用它即可。为此，`SynchronizationContext`提供了一个`Current`属性，以便实现上述目标，代码可能写成这样：

```csharp
public void DoWork(Action worker, Action completion)
{
    SynchronizationContext sc = SynchronizationContext.Current;
    ThreadPool.QueueUserWorkItem( _ => 
        {
        	try {worker();}
            finally {sc.Post( _ => completion(), null ); }
    	}
    );
}
```

想要从`Current`公开自定义上下文的框架使用`SynchronizationContext.SetSynchronizationContext`方法。



### 什么是TaskScheduler?

`SynchronizationContext`是对“scheduler”的通用抽象。独立的框架有时候有它自己对“scheduler”的抽象，`System.Threading.Tasks`也不例外（is no exception）。当`Task`s由delegate支持并且可以排队和执行的时候，它就与`System.Threading.Tasks.TaskScheduler`相关联。像`SynchronizationContext`提供一个virtual `Post`的方法用于排队delegeate的调用一样，`TaskScheduler`提供一个abstract `QueueTask`方法（通过`ExecuteTask`方法来实现稍后调用`Task`）。

`TaskScheduler.Default`默认返回的sheduler是线程池（thread pool），但可以通过派生`TaskScheduler`并且重写相关的方法实现任意时间任意地方调用`Task`。比如包括`System.Threading.Tasks.ConcurrentExclusiveSchedulerPair`在内的核心库都有这种实现。这个类的实例有两个`TaskScheduler`属性，一个`ExclusiveScheduler`，一个`ConcurrentScheduler`。在`ConcurrentScheduler`中调度的`Task`可能会被并发的调用，但受`ConcurrentExclusiveSchedulerPair`参数的限制（构造函数的时候提供），而且在`ExclusiveScheduler`中的`Task`运行的时候`ConcurrentScheduler`中的`Task`则不会执行，`ExclusiveScheduler`一次只允许一个`Task`运行，这个行为很像一个读写锁。

像`SynchronizationContext`那样，`TaskScheduler`也有一个`Current`属性，用于返回“当前的” `TaskScheduler`。而不像`SynchronizationContext`的，没有方法支持set当前的scheduler。相反，当前的scheduler（调度程序）是与当前运行的Task相关联的scheduler，并且scheduler作为启动Task的一部分提供给系统。举个例子，下面的程序将输出“ True”，因为与StartNew一起使用的lambda是在`ConcurrentExclusiveSchedulerPair`的`ExclusiveScheduler`上执行的，并且将看到`TaskScheduler.Current`设置为该调度程序：

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        var cesp = new ConcurrentExclusiveSchedulerPair();
        Task.Factory.StartNew(
            () => {
                Console.WriteLine(TaskScheduler.Current == cesp.ExclusiveScheduler);
            },
            default,
            TaskCreationOptions.None, cesp.ExclusiveScheduler
        ).Wait();
    }
}
```

有趣的是，`TaskScheduler`提供了一个静态的`FromCurrentSynchronizationContext`方法，该方法创建了一个新的`TaskScheduler`，该任务将任务排队，以便在其返回的`SynchronizationContext.Current`上运行，并使用其Post方法对任务进行排队。



### 那么，SynchronizationContext 与 TaskScheduler 与 await 有什么关系呢？

