---
title: "《游戏开发中的数学与物理》"
date: 2021-04-27T11:49:09+08:00
draft: false
isCJKLanguage: true
---

# 第一章

## 1.3 让物体沿任意方向运动

### 1.3.0 请将角的单位统一为弧度

为什么计算机中的正弦余弦函数不适用看上去比较亲切易懂的角度，而用了看来不够直观的弧度呢？

其实在近代数学中，三角函数几乎都使用弧度，很少会使用角度。之所以使用弧度而不是使用角度作为角的度量单位，主要是关系到微积分的一些问题。如果坚持不适用弧度的话，三角函数中与微积分相关的一些公式几乎都无法使用，还可能会引发一些严重的问题。特别是游戏中会有与物理相关的公式，稍复杂的情况都会出现微积分的计算，因此读者朋友们在程序中涉及角的度量时，请务必使用弧度而不要使用角度。如果在一个程序中同时使用弧度和角度，就会非常容易出现BUG以及各种问题，因此将角的度量单位无条件统一为弧度这一原则，应当被无条件的贯彻下去。

> ❗ 注意：
>
> 代码中需要将弧度的大小限制在 0 ~ 2π 
>
> 尽管数学中可以任意的将弧度无限大的写下去，但计算机中由于弧度是用浮点数表示的，所以过大的弧度，会导致计算时的精度丢失问题。



## 1.4 在物体运动中加入重力

> 关键词：抛物运动、重力加速度、计算误差、积分

### 1.4.1 关于重力加速度的单位

游戏中配置的重力加速度值并不是自然界中平时使用的9.8。众所周知的重力加速度值9.8是真实的地球上的重力加速度，以 `m/s²(米/平方秒)`为单位，并不能在计算机的虚拟空间中适用。计算机所使用的重力加速度单位是特殊的`dot/F²(像素/平方帧)`，请注意区别。

> 书中示例的重力加速度值是 `0.4 dot/F²`
>
> UCC插件中使用的默认重力加速度是`3.92 dot/F²`
>
> > 百度百科：
> >
> > 大多数网页制作常用图片分辨率为72，即每英寸像素72。一英寸等于2.54厘米，那么一厘米大约28像素
>
> 按照一厘米28像素，一秒60帧换算如下：
>
> `9.8 * 28 * 100 / (60 * 60) = 7.62 dot/F²` 
>
> 反过来推算每厘米的像素数：
>
> `3.92 * 60 * 60 / (9.8 * 100) = 14.4 像素/每厘米`
>
> 🤔这个单位换算哪里怪怪的



### 1.4.2 使用积分进行计算重力运行的轨迹

当存在加速度时，一帧的开始时和结束时速度是不一样的，那么要如何计算这一帧的移动距离呢？

可以使用取平均速度来拟合，当然更好的办法是根据加速度、起始速度、时间，求积分，积分结果为移动的距离。

>关于重力加速度造成的竖直方向的移动轨迹计算的比较：
>
>普通的拟合运算： `y = 1/2 * G * t * t + C2`（C2是初始位置）
>
>积分运算： `y = 1/2 * G * t * t + C1 * t + C2`  （ C1是初始速度， C2是初始位置）
>
>显然，随着时间的推移，后面的 `C1 * t` 造成的误差会越来越大

对位置叠加速度，再对速度叠加加速度这一简单算法，再程序中随着时间的推进，误差会越来越大。如果真正的游戏中出现了这种误差，游戏的玩家很可能会认为游戏有问题。

比如球类比赛游戏中，球的旋转以及空气摩擦的影响等因素都必须考虑在内，如果有误差就有可能会影响球的运动轨迹。在动作游戏中，一点微小的动作偏差都会影响游戏性，最终演变成大问题。

> ❗ 注意：
>
> 那么是不是使用上面的积分来精确计算轨道就万无一失了呢？很遗憾这是不可能的。如果地球上只有重力这一种力的话还没什么问题，但是物体运动往往受到多个复杂的力的共同作用，想精确求得物体每一个瞬间的轨道几乎是不可能的，这种情况下只能根据数据计算物体近似的运动轨道。



## 1.5 物体随机飞溅运动

> 关键词：随机数、均匀随机数、正态分布
>
> 比如火山喷发、烟花、摩擦迸出的火花等，不过物体飞溅运动其本质也是抛物线运动

### 1.5.0 产生随机数时注意事项

RAND_MAX 为`rand()`函数返回的最大值，

获取`0 ~ 1`之间的随机数：

- `rand() / ( float )RAND_MAX`

获取`0 ~ n`之间的随机数：

- `( rand() / (float)RAND_MAX ) * n`（不推荐）

- ` rand() * n / (float)RAND_MAX `（推荐）

如果`n`是整型，那么第二种写法先执行整型乘法，速度更快🤔。

### 1.5.1 正态分布，使火山喷发的随机速度看起来更自然

> 自然界中火山喷发的初速度分布并不是**均匀随机数**，而是满足**正态分布**的

**Box-Muller算法**是一种能根据均匀分布的随机数来产生正态分布的随机数的算法：

假设**a**、**b**是两个服从均匀分布并且取值范围为从0到1的随机数，我们就可以通过下面的公式获得两个满足正太分布（均数为0，标准差为1）的随机数Z1和Z2。
$$
Z_1 = \sqrt{-2ln(a)} cos(2 \pi b)
$$

$$
Z_2 = \sqrt{-2ln(a)} sin(2 \pi b)
$$

等式中的`ln(x)`代表自然对数的函数，上式对应的图像是在半径为 
$$
\sqrt{-2ln(a)}
$$

的圆上取随机角度的点，点的x坐标为Z1，y坐标为Z2。为什么这样的Z1和Z2会满足正态分布呢？超出本书范畴，略过。



## 1.6 让物体进行圆周运动

> 关键词：角速度、向心力

### 1.6.1 基于三角函数实现圆周运动

普通的做法，不考虑物体运动中速度和加速度的情况（比如重力），而是直接计算了物体的位置。我们知道根据三角函数的正弦余弦定义有
$$
x = cos\theta \space\space y = sin\theta
$$

在一个以原点为中心的单位圆上，根据角度θ就可以表示一个点的位置（参考图1-6-2）。

如果上式中θ的值随实践递增，就会形成以原点为中心半径为1的圆周运动（参考图1-6-3）。

将这个圆的半径乘以r，并将原点的位置设置为(x0, y0)，那么围绕着(x0, y0)的半径为r的圆周运动就为
$$
x = r \cdot cos\theta + x_0
$$

$$
y = r \cdot sin\theta + y_0
$$
![](/images/038/1-6-2.png)

在物理学中表示物体的旋转速度时常使用**角速度**。角速度为w：
$$
w = \dfrac{\theta}{t}
$$
周期T为旋转一周的时间
$$
w = \dfrac{2\pi}{T} \space即\space \theta = 2\pi\dfrac{t}{T}
$$

### 1.6.2 基于向心力实现圆周运动（性能更好）

> ❗那么如果速度中包含了加速度的圆周运动如何计算呢？（比如有重力和空气阻力）  
> ❗或者处理不完整的圆周运动（荡秋千）

> 使用微分处理圆周运动中的加速度

微分的运算过程是分别算单位时间内，x方向和y方向的速度、加速度随时间的函数：
$$
速度v = \dfrac{dx}{dt}
$$
$$
加速度a = \dfrac{dv}{dt}
$$

x方向的位置函数用角速度表达如下：
$$
x = r \cdot cos(wt)
$$
x方向的速度计算如下：
$$
v_x = \dfrac{dx}{dt} = \dfrac{d}{dt}\{r \cdot cos(wt)\} = -rw \cdot sin(wt)
$$
x方向的加速度计算如下：
$$
a_x = \dfrac{dv_x}{dt} = \dfrac{d}{dt}\{(-rw \cdot sin(wt))\} = -rw^2 \cdot cos(wt)
$$
将上面x的等式带入可获得：
$$
a_x = -w^2x
$$
同理可得：
$$
a_y = -w^2y
$$
从向量的角度来重新审视一下上面的等式，可以得出这样一个结论，即将物体所在的位置乘以 `-w² `作为加速度，就会形成以原点为中心的圆周运动（参考图1-6-4）。

![](/images/038/1-6-4.png)

等式中的负号，表示被施加的加速度（或力）是始终指向原点（即旋转的中心方向）的。于是我们就可以得出结论，即**对物体施加一个指向某一点的角速度为w的力，物体就会围绕该点做圆周运动。**这个力也被称为**向心力**。

❗由于基于向心力实现圆周运动并没有使用sin、cos等三角函数进行运算，只是简单的使用了加法乘法等，而最终效果与使用了三角函数的圆周运动是完全一样的。这种方式性能更好。

❗也正是因为x、y方向的速度、加速度分开计算，所以也更容易加入重力加速度的实现。



## 1.7 [进阶]微分方程式及其数值解法

> 关键词：微分方程、数值解法、欧拉法

### 求解积分

有一些运动方程可以通过微积分运算求得，比如重力加速度下的物体运动轨迹x满足积分公式：
$$
\int \dfrac{d^2x}{dt^2} dt = \int g dt
$$

可求得：
$$
x = \frac{1}{2}gt^2 + C_0t + C_1
$$

### 利用三角函数求解积分

但现实中几乎没有人会像这样对运动方程进行积分求解。例如，根据**胡克定律**，具有弹性的物体会被施加一个名为 `-kx`的力，k称为**劲度系数**，弹簧越硬劲度系数越大，此时积分公式为：
$$
\dfrac{d^2x}{dt^2} = \dfrac{-kx}{m}
$$

这个公式无法简单的对两边进行积分求解x，因为积分求解的对象是x，而x在等式右边也出现了。换一种思路，可以利用三角函数两次积分会变回原来的样子来求解。（求解过程略）

### 微分方程的数值解法（欧拉法）

上面介绍了运动方程的两种解法：对等式两边积分以及利用三角函数。但很遗憾，并不是所有微分方程都可以通过这两种方法求解。数学家的研究成果是线性微分方程必然有解，非线性微分方程会存在一些无论如何都无法求解的情况。

我们要使用**微分方程的数值解法**，又叫**欧拉法**。所谓**欧拉法**，就是通过逐步计算来求得微分方程的近似解。

举个例子：

位置x与速度v之间的关系
$$
\dfrac{dx}{dt} = v
$$
在欧拉法中表示为
$$
\dfrac{\Delta x}{\Delta t} = v
$$
这里的Δt是时间间隔（**在游戏中就是1帧**）。用n-1表示前一次的位置，n表示当前的位置
$$
x_n = x_{n-1} + v\Delta t
$$
同理，速度与加速度的关系为
$$
v_n = v_{n-1} + a\Delta t
$$
只要Δt足够小就直接转化为了微分，也就不是近似值了。游戏中经常会把欧拉法的等式中的Δt设置为1，即
$$
\begin{cases}
  x_n = n_{n-1} + v\\
  v_n = v_{n-1} + a
\end{cases}
$$
这样计算所使用的时间间隔就变成了1帧，即1/60秒。在物体被施加了加速度的情况下，这样计算所产生的误差是无法被忽视的。即便如此，很多游戏中也并不会去要求更高的计算精度，因为此时物体的动作肉眼观察起来并不会感到奇怪，这就足够了。

如果一些情况需要提高精度的话（比如球类游戏），一般有一下三个方法：

1. 使用精度更高的高阶近似求解微分方程，比如龙格-库塔法等。
2. 使用线性多步法计算，即不光使用前一次的值，还使用前两次或更早的值进行计算，比如Adams-Bashforth法等。
3. 在一帧内多次使用欧拉法计算，缩小Δt。

方法一偏理论，代码维护性差，而且龙格-库塔法本身有很多版本，会有混乱，请慎重

方法二比一略简单一些，也没有那么多不同版本，但毫无疑问还是比欧拉法复杂，斟酌使用

方法三最常用，循环10次欧拉法就很好用了。



# 第二章

## 2.1 将背景从一段卷动到另一端

> 关键词：镜头位置、卷动幅度、比例关系



