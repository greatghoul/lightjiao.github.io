---
title: "《游戏开发中的数学与物理》"
date: 2021-04-27T11:49:09+08:00
draft: false
isCJKLanguage: true
---

# 第一章 物体的运动

## 1.3 让物体沿任意方向运动

### 1.3.0 请将角的单位统一为弧度

为什么计算机中的正弦余弦函数不适用看上去比较亲切易懂的角度，而用了看来不够直观的弧度呢？

其实在近代数学中，三角函数几乎都使用弧度，很少会使用角度。之所以使用弧度而不是使用角度作为角的度量单位，主要是关系到微积分的一些问题。如果坚持不适用弧度的话，三角函数中与微积分相关的一些公式几乎都无法使用，还可能会引发一些严重的问题。特别是游戏中会有与物理相关的公式，稍复杂的情况都会出现微积分的计算，因此读者朋友们在程序中涉及角的度量时，请务必使用弧度而不要使用角度。如果在一个程序中同时使用弧度和角度，就会非常容易出现BUG以及各种问题，因此将角的度量单位无条件统一为弧度这一原则，应当被无条件的贯彻下去。

> ❗ 注意：
>
> 代码中需要将弧度的大小限制在 0 ~ 2π 
>
> 尽管数学中可以任意的将弧度无限大的写下去，但计算机中由于弧度是用浮点数表示的，所以过大的弧度，会导致计算时的精度丢失问题。



## 1.4 在物体运动中加入重力

> 关键词：抛物运动、重力加速度、计算误差、积分

### 1.4.1 关于重力加速度的单位

游戏中配置的重力加速度值并不是自然界中平时使用的9.8。众所周知的重力加速度值9.8是真实的地球上的重力加速度，以 `m/s²(米/平方秒)`为单位，并不能在计算机的虚拟空间中适用。计算机所使用的重力加速度单位是特殊的`dot/F²(像素/平方帧)`，请注意区别。

> 书中示例的重力加速度值是 `0.4 dot/F²`
>
> UCC插件中使用的默认重力加速度是`3.92 dot/F²`
>
> > 百度百科：
> >
> > 大多数网页制作常用图片分辨率为72，即每英寸像素72。一英寸等于2.54厘米，那么一厘米大约28像素
>
> 按照一厘米28像素，一秒60帧换算如下：
>
> `9.8 * 28 * 100 / (60 * 60) = 7.62 dot/F²` 
>
> 反过来推算每厘米的像素数：
>
> `3.92 * 60 * 60 / (9.8 * 100) = 14.4 像素/每厘米`
>
> 🤔这个单位换算哪里怪怪的



### 1.4.2 使用积分进行计算重力运行的轨迹

当存在加速度时，一帧的开始时和结束时速度是不一样的，那么要如何计算这一帧的移动距离呢？

可以使用取平均速度来拟合，当然更好的办法是根据加速度、起始速度、时间，求积分，积分结果为移动的距离。

>关于重力加速度造成的竖直方向的移动轨迹计算的比较：
>
>普通的拟合运算： `y = 1/2 * G * t * t + C2`（C2是初始位置）
>
>积分运算： `y = 1/2 * G * t * t + C1 * t + C2`  （ C1是初始速度， C2是初始位置）
>
>显然，随着时间的推移，后面的 `C1 * t` 造成的误差会越来越大

对位置叠加速度，再对速度叠加加速度这一简单算法，再程序中随着时间的推进，误差会越来越大。如果真正的游戏中出现了这种误差，游戏的玩家很可能会认为游戏有问题。

比如球类比赛游戏中，球的旋转以及空气摩擦的影响等因素都必须考虑在内，如果有误差就有可能会影响球的运动轨迹。在动作游戏中，一点微小的动作偏差都会影响游戏性，最终演变成大问题。

> ❗ 注意：
>
> 那么是不是使用上面的积分来精确计算轨道就万无一失了呢？很遗憾这是不可能的。如果地球上只有重力这一种力的话还没什么问题，但是物体运动往往受到多个复杂的力的共同作用，想精确求得物体每一个瞬间的轨道几乎是不可能的，这种情况下只能根据数据计算物体近似的运动轨道。



## 1.5 物体随机飞溅运动

> 关键词：随机数、均匀随机数、正态分布
>
> 比如火山喷发、烟花、摩擦迸出的火花等，不过物体飞溅运动其本质也是抛物线运动

### 1.5.0 产生随机数时注意事项

RAND_MAX 为`rand()`函数返回的最大值，

获取`0 ~ 1`之间的随机数：

- `rand() / ( float )RAND_MAX`

获取`0 ~ n`之间的随机数：

- `( rand() / (float)RAND_MAX ) * n`（不推荐）

- ` rand() * n / (float)RAND_MAX `（推荐）

如果`n`是整型，那么第二种写法先执行整型乘法，速度更快🤔。

### 1.5.1 正态分布，使火山喷发的随机速度看起来更自然

> 自然界中火山喷发的初速度分布并不是**均匀随机数**，而是满足**正态分布**的

**Box-Muller算法**是一种能根据均匀分布的随机数来产生正态分布的随机数的算法：

假设**a**、**b**是两个服从均匀分布并且取值范围为从0到1的随机数，我们就可以通过下面的公式获得两个满足正太分布（均数为0，标准差为1）的随机数Z1和Z2。
$$
Z_1 = \sqrt{-2ln(a)} cos(2 \pi b)
$$

$$
Z_2 = \sqrt{-2ln(a)} sin(2 \pi b)
$$

等式中的`ln(x)`代表自然对数的函数，上式对应的图像是在半径为 
$$
\sqrt{-2ln(a)}
$$

的圆上取随机角度的点，点的x坐标为Z1，y坐标为Z2。为什么这样的Z1和Z2会满足正态分布呢？超出本书范畴，略过。



## 1.6 让物体进行圆周运动

> 关键词：角速度、向心力

### 1.6.1 基于三角函数实现圆周运动

普通的做法，不考虑物体运动中速度和加速度的情况（比如重力），而是直接计算了物体的位置。我们知道根据三角函数的正弦余弦定义有
$$
x = cos\theta \space\space y = sin\theta
$$

在一个以原点为中心的单位圆上，根据角度θ就可以表示一个点的位置（参考图1-6-2）。

如果上式中θ的值随实践递增，就会形成以原点为中心半径为1的圆周运动（参考图1-6-3）。

将这个圆的半径乘以r，并将原点的位置设置为(x0, y0)，那么围绕着(x0, y0)的半径为r的圆周运动就为
$$
x = r \cdot cos\theta + x_0
$$

$$
y = r \cdot sin\theta + y_0
$$
![](https://raw.githubusercontent.com/lightjiao/lightjiao.github.io/develop/static/images/038/1-6-2.png)

在物理学中表示物体的旋转速度时常使用**角速度**。角速度为w：
$$
w = \dfrac{\theta}{t}
$$
周期T为旋转一周的时间
$$
w = \dfrac{2\pi}{T} \space即\space \theta = 2\pi\dfrac{t}{T}
$$

### 1.6.2 基于向心力实现圆周运动（性能更好）

> ❗那么如果速度中包含了加速度的圆周运动如何计算呢？（比如有重力和空气阻力）  
> ❗或者处理不完整的圆周运动（荡秋千）

> 使用微分处理圆周运动中的加速度

微分的运算过程是分别算单位时间内，x方向和y方向的速度、加速度随时间的函数：
$$
速度v = \dfrac{dx}{dt}
$$
$$
加速度a = \dfrac{dv}{dt}
$$

x方向的位置函数用角速度表达如下：
$$
x = r \cdot cos(wt)
$$
x方向的速度计算如下：
$$
v_x = \dfrac{dx}{dt} = \dfrac{d}{dt}\{r \cdot cos(wt)\} = -rw \cdot sin(wt)
$$
x方向的加速度计算如下：
$$
a_x = \dfrac{dv_x}{dt} = \dfrac{d}{dt}\{(-rw \cdot sin(wt))\} = -rw^2 \cdot cos(wt)
$$
将上面x的等式带入可获得：
$$
a_x = -w^2x
$$
同理可得：
$$
a_y = -w^2y
$$
从向量的角度来重新审视一下上面的等式，可以得出这样一个结论，即将物体所在的位置乘以 `-w² `作为加速度，就会形成以原点为中心的圆周运动（参考图1-6-4）。

![](https://raw.githubusercontent.com/lightjiao/lightjiao.github.io/develop/static/images/038/1-6-4.png)

等式中的负号，表示被施加的加速度（或力）是始终指向原点（即旋转的中心方向）的。于是我们就可以得出结论，即**对物体施加一个指向某一点的角速度为w的力，物体就会围绕该点做圆周运动。**这个力也被称为**向心力**。

❗由于基于向心力实现圆周运动并没有使用sin、cos等三角函数进行运算，只是简单的使用了加法乘法等，而最终效果与使用了三角函数的圆周运动是完全一样的。这种方式性能更好。

❗也正是因为x、y方向的速度、加速度分开计算，所以也更容易加入重力加速度的实现。



## 1.7 [进阶]微分方程式及其数值解法

> 关键词：微分方程、数值解法、欧拉法

### 求解积分

有一些运动方程可以通过微积分运算求得，比如重力加速度下的物体运动轨迹x满足积分公式：
$$
\int \dfrac{d^2x}{dt^2} dt = \int g dt
$$

可求得：
$$
x = \frac{1}{2}gt^2 + C_0t + C_1
$$

### 利用三角函数求解积分

但现实中几乎没有人会像这样对运动方程进行积分求解。例如，根据**胡克定律**，具有弹性的物体会被施加一个名为 `-kx`的力，k称为**劲度系数**，弹簧越硬劲度系数越大，此时积分公式为：
$$
\dfrac{d^2x}{dt^2} = \dfrac{-kx}{m}
$$

这个公式无法简单的对两边进行积分求解x，因为积分求解的对象是x，而x在等式右边也出现了。换一种思路，可以利用三角函数两次积分会变回原来的样子来求解。（求解过程略）

### 微分方程的数值解法（欧拉法）

上面介绍了运动方程的两种解法：对等式两边积分以及利用三角函数。但很遗憾，并不是所有微分方程都可以通过这两种方法求解。数学家的研究成果是线性微分方程必然有解，非线性微分方程会存在一些无论如何都无法求解的情况。

我们要使用**微分方程的数值解法**，又叫**欧拉法**。所谓**欧拉法**，就是通过逐步计算来求得微分方程的近似解。

举个例子：

位置x与速度v之间的关系
$$
\dfrac{dx}{dt} = v
$$
在欧拉法中表示为
$$
\dfrac{\Delta x}{\Delta t} = v
$$
这里的Δt是时间间隔（**在游戏中就是1帧**）。用n-1表示前一次的位置，n表示当前的位置
$$
x_n = x_{n-1} + v\Delta t
$$
同理，速度与加速度的关系为
$$
v_n = v_{n-1} + a\Delta t
$$
只要Δt足够小就直接转化为了微分，也就不是近似值了。游戏中经常会把欧拉法的等式中的Δt设置为1，即
$$
\begin{cases}
  x_n = n_{n-1} + v\\
  v_n = v_{n-1} + a
\end{cases}
$$
这样计算所使用的时间间隔就变成了1帧，即1/60秒。在物体被施加了加速度的情况下，这样计算所产生的误差是无法被忽视的。即便如此，很多游戏中也并不会去要求更高的计算精度，因为此时物体的动作肉眼观察起来并不会感到奇怪，这就足够了。

如果一些情况需要提高精度的话（比如球类游戏），一般有一下三个方法：

1. 使用精度更高的高阶近似求解微分方程，比如龙格-库塔法等。
2. 使用线性多步法计算，即不光使用前一次的值，还使用前两次或更早的值进行计算，比如Adams-Bashforth法等。
3. 在一帧内多次使用欧拉法计算，缩小Δt。

方法一偏理论，代码维护性差，而且龙格-库塔法本身有很多版本，会有混乱，请慎重

方法二比一略简单一些，也没有那么多不同版本，但毫无疑问还是比欧拉法复杂，斟酌使用

方法三最常用，循环10次欧拉法就很好用了。



# 第二章 卷动

## 2.3 卷动由地图块组合的地图

> 关键词：地图、地图块、整数的减法、位移运算、逻辑运算

### 位移运算

- 用 `>> 6` 来代替除以64（64是2的6次方）

  > 以前CPU指令中还没有除法运算，或者除法运算特别花时间的时期多用这种手法。
  >
  > 但现在除法运算指令已经非常高速。
  >
  > 现代的CPU中大都内置了名为“桶形移位器”的逻辑电路，可以在一个时钟周期内进行任意长度的位移，因此如果是在数量非常巨大的循环中，将除法运算替换为位运算会获得更快的速度。

- 用`& 0x3f`来代替乘以64（TODO）

  > 现在CPU中乘法运算的速度与逻辑运算的速度差别比起以前已经非常小了，因此使用逻辑运算的必要性也变小了。
  >
  > 不过即便乘法运算能在CPU的一个时钟周期内完成，但乘法运算和逻辑运算分别在CPU的不同单元中处理时，由于按顺序执行的乘法运算和逻辑运算可以并行处理，因此还不能说逻辑运算已经完全可以被替代。



## 2.4 波纹式的摇摆卷动

> 关键词：波纹扭曲、正弦波、波长、振幅、周期

将一张图片的各个部分通过卷动变形，并呈现波纹式的摇摆。其实就是将图片按像素划分成一行一行，分别修改每一行的渲染的起始坐标。

### 正弦波

![](https://raw.githubusercontent.com/lightjiao/lightjiao.github.io/develop/static/images/038/2-4-4.png)
$$
y = A \cdot sin(\dfrac{2\pi}{\lambda} x)
$$
公式中的正弦波包含振幅A与波长λ两个特征。

振幅A表示振动的幅度大小，振幅越大说明波震动的幅度越大。

波长λ表示波在1个周期内波动的距离，其值越大，波形越宽。

包含时间的正弦波公式：
$$
y = A \cdot sin\{2\pi(\dfrac{t}{T} - \dfrac{x}{\lambda})\}
$$
变量t表示经过的时间。在这个正弦波公式中出现了振幅A、波长λ，还有周期T。

周期T表示多长时间是一个周期，其值越大，一次波动所经过的时间越长。

上式中时间每推进T，正弦函数中就增加2π。

自然界中存在很多种波，与正弦波相似的波也有不少，因此通过正弦波就能大致表现出很多真实世界中的波（但是像水面那样的波严格来说并不是正弦波）。



## 2.5 制作有纵深感的卷动

> 关键词：透视、比例计算、梯形

用2D图像表现出有纵深的3D效果。



## 2.6 [进阶]透视理论

并没有很复杂，就是利用3D坐标到视点的位置连线，计算出连线与屏幕位置的焦点，然后在该点绘制出图形

透视用的是一个三角锥体，也有直接用矩形立方体的就没有透视

不过这样也是有缺陷的，主要缺陷来源于将人的眼睛视为一个点，实际上人眼是两个眼睛，而且会有不同的观察角度。对应这种复杂情况的显示，就是VR、裸眼3D等技术了。



# 第三章 碰撞检测

## 3.1 长方形物体间的碰撞检测

> 关键词：矩形、德摩根定律

**德摩根定律**：首先考虑两个物体什么情况下时不可能重叠的，比如有矩形1、矩形2两个矩形，如果矩形1的右端比矩形2的左端还靠左，那么就认为两个矩形不可能重叠（参考图3-1-3左）。同理，如果矩形1的左端比矩形2的右端还要靠右，也可以认为两个矩形不可能重叠（参考图3-1-3右）。

![](https://raw.githubusercontent.com/lightjiao/lightjiao.github.io/develop/static/images/038/3-1-3.png)

因此在与上述结论相反的情况下，两个矩形就可能重叠，即矩形1的右端比矩形2的左端靠右，并且矩形1的左端比矩形2的右端靠左时，两个矩形时可能重叠的。

❗❗❗ 当矩形的两端正好位于同一位置的情况，即“矩形1的右端与矩形2的左端正好在同一位置”：

矩形是基于左上角及右下角的坐标绘制的，而在现代硬件中，这样的矩形的右端及下端的最后1像素正好会被省略。

> 在现代的3D硬件中比如要绘制左上角为（10，10），右下角为（20，20）的矩形时，最左端的第10像素会被绘制，而最右端的第20像素一般则不会被绘制出来。垂直方向也一样，上端的第10像素会被绘制，而最下端的第20像素一般则不会被绘制。

至于为什么会有这样的设定，我也没有详细了解过，但按照这样的设定，并且考虑到让碰撞检测的可视化效果更加真实，当端与端位于同一位置时，我们认为设定其为没有碰撞。

不过这种处理方式不能作为开发类似程序的统一标准，因为在众多绘图硬件及程序库中，也许存在特例会将图形的右端及下端也进行绘制。因此端与端在同一位置的碰撞检测，还是需要根据具体情况来决定如何处理。



## 3.2 圆形与圆形、圆形与长方形物体间的碰撞检测

> 关键词：距离、勾股定理、平方比较

### 圆与圆之间的碰撞检测

判断两圆是否有碰撞，只要将两圆圆心之间的距离与两圆的半径之和比较即可（参考图3-2-2）。如此依赖就无需再考虑一个圆是否完全包含另一个圆，或者两圆之间是否有交点等情况。

![](https://raw.githubusercontent.com/lightjiao/lightjiao.github.io/develop/static/images/038/3-2-2.png)

计算公式也简单，使用勾股定理计算出圆心距离：
$$
l = \sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}
$$
再和两圆的半径之和比较，如果小于则可判定为碰撞。

![](https://raw.githubusercontent.com/lightjiao/lightjiao.github.io/develop/static/images/038/3-2-3.png)

> ❗ 在计算机中计算时，可以不计算平凡根，性能开销比较大，可以直接比较两个数的平方
>
> 根据硬件结构的不同，两者的差距有时可达10倍以上。



### 圆形与长方形的碰撞检测

